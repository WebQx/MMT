image:
  repository: yourrepo/mmt-backend
  tag: latest
  pullPolicy: IfNotPresent

rabbitmq:
  enabled: true
  auth:
    username: user
    password: password
  url: amqp://user:password@mmt-rabbitmq:5672/

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
  url: redis://mmt-redis-master:6379/0

env:
  ENV: prod
  OPENEMR_FHIR_BASE_URL: ""
  OPENEMR_FHIR_CLIENT_ID: ""
  OPENEMR_FHIR_CLIENT_SECRET: ""
  OPENEMR_FHIR_USERNAME: ""
  OPENEMR_FHIR_PASSWORD: ""
  OPENEMR_FHIR_REDIRECT_URI: ""
  RATE_LIMIT_PER_MINUTE: 120
  RETENTION_DAYS: 0
  STORE_PHI: "true"
  ENABLE_IDEMPOTENCY: "true"
  IDEMPOTENCY_CACHE_SIZE: 5000
  IDEMPOTENCY_TTL_SECONDS: 3600
  USE_BLOOM_IDEMPOTENCY: "false"
  BLOOM_ERROR_RATE: 0.001
  BLOOM_CAPACITY: 100000
  USE_RSA_INTERNAL_JWT: "false"
  DRAIN_WAIT_SECONDS: 60
  ENABLE_DB_IDEMPOTENCY: "false"
  IDEMPOTENCY_DB_TTL_SECONDS: 86400
  VAULT_ADDR: ""
  VAULT_RSA_SECRET_PATH: ""
  ENABLE_FIELD_ENCRYPTION: "false"
  ENCRYPTION_KEYS: ""  # key1:base64key,key2:base64key (mount via secret)
  PRIMARY_ENCRYPTION_KEY_ID: ""
  ENCRYPTION_ROTATE_HOURS: 0
  # Production hardening
  AUDIT_LOG_FILE: "/app/logs/audit.log"
  ENFORCE_TLS_IN_PRODUCTION: "true"
  # Worker optimization
  ASYNC_MAX_WORKERS: 4
  ASYNC_QUEUE_MAXSIZE: 100
  WORKER_POOL_OPTIMIZATION_ENABLED: "true"
  MIN_WORKERS_PER_CORE: 1
  MAX_WORKERS_PER_CORE: 4
  # External services
  EXTERNAL_RABBITMQ_ENABLED: "false"
  EXTERNAL_REDIS_ENABLED: "false"
  # RedisBloom idempotency
  ENABLE_REDIS_BLOOM_IDEMPOTENCY: "false"
  REDIS_BLOOM_KEY_PREFIX: "mmt:bloom:"
  REDIS_BLOOM_TTL_SECONDS: 86400
  # Async task retention
  ASYNC_TASK_RETENTION_DAYS: 7
  ASYNC_CLEANUP_INTERVAL_HOURS: 24

service:
  type: ClusterIP
  port: 80
  # Container listen port
  targetPort: 9000

resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 500m
    memory: 512Mi

# Retention job configuration
retention:
  schedule: "0 2 * * *"  # Run at 2 AM daily
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi

# Database configuration
database:
  secretName: "mmt-database"
  secretKey: "url"

# Audit logging persistence
auditLogs:
  enabled: true
  storageClass: ""
  size: 10Gi
  accessMode: ReadWriteOnce

# TLS configuration
tls:
  enabled: false
  secretName: "mmt-tls"
  certFile: "tls.crt"
  keyFile: "tls.key"

podSecurityContext:
  enabled: true
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

containerSecurityContext:
  enabled: true
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]

sidecars:
  reprocessor:
    enabled: false
    resources:
      requests:
        cpu: 50m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi
    args: []

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts: []  # [{host: example.com}]
  tls: []    # [{hosts: [example.com], secretName: example-tls}]

serviceMonitor:
  enabled: false
  interval: 30s
  path: /metrics

alerts:
  enabled: false

extraEnv: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  queueDepthTarget: 5  # average queue depth per pod
  cpu:
    enabled: true
    targetAverageUtilization: 70

keda:
  enabled: false
  pollingInterval: 15
  cooldownPeriod: 120
  minReplicaCount: 1
  maxReplicaCount: 10
  rabbitmq:
    queueName: openemr_transcriptions
    queueLength: 50  # scale when > this many messages
    hostFromSecret: rabbitmq-credentials
    hostFromSecretKey: connection

vault:
  approle:
    roleId: ""
    secretId: ""

secrets:
  enabled: true
  # Kubernetes Secret names containing sensitive values (mounted as env via envFrom or individual refs)
  fhir:
    secretName: "fhir-credentials"  # keys: client-id, client-secret, username, password
  db:
    secretName: "transcripts-db"     # keys: host, user, password, name
  rabbitmq:
    secretName: "rabbitmq-conn"      # key: url
  redis:
    secretName: "redis-conn"         # key: url
  vault:
    secretName: "vault-approle"      # keys: roleId, secretId
  encryption:
    secretName: "encryption-keys"    # keys: keys, primary-id
